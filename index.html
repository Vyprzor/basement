<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BASEMENT - Horror Game</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: 'Courier New', monospace; overflow: hidden; background: #000; cursor: none; }
        #gameCanvas { display: block; }
        #hud { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; color: #fff; }
        #inventory { position: absolute; top: 20px; right: 20px; background: rgba(10,0,0,0.9); padding: 15px 20px; border: 1px solid #440000; font-size: 14px; box-shadow: 0 4px 30px rgba(100,0,0,0.5); }
        #inventory h3 { margin-bottom: 8px; color: #666; font-size: 11px; letter-spacing: 2px; }
        #keyStatus { color: #aaa; }
        #compass { position: absolute; top: 20px; left: 20px; width: 70px; height: 70px; background: rgba(10,0,0,0.9); border: 1px solid #440000; border-radius: 50%; display: flex; align-items: center; justify-content: center; font-size: 24px; font-weight: bold; color: #a00; box-shadow: 0 4px 30px rgba(100,0,0,0.5); }
        #objectives { position: absolute; top: 110px; left: 20px; background: rgba(10,0,0,0.9); padding: 15px 20px; border: 1px solid #440000; max-width: 260px; box-shadow: 0 4px 30px rgba(100,0,0,0.5); }
        #objectives h3 { margin-bottom: 10px; color: #666; font-size: 11px; letter-spacing: 2px; }
        #objectives ul { list-style: none; padding-left: 0; }
        #objectives li { margin: 6px 0; font-size: 13px; color: #999; }
        #objectives li.complete { text-decoration: line-through; color: #0a0; }
        #map { position: absolute; bottom: 20px; right: 20px; width: 250px; height: 250px; background: rgba(10,0,0,0.9); border: 1px solid #440000; padding: 10px; box-shadow: 0 4px 30px rgba(100,0,0,0.5); }
        #pauseMenu { position: absolute; top: 50%; left: 50%; transform: translate(-50%,-50%); background: rgba(0,0,0,0.98); padding: 50px 60px; border: 2px solid #8a0000; text-align: center; display: none; pointer-events: all; box-shadow: 0 0 80px rgba(138,0,0,0.8); }
        #pauseMenu h2 { color: #c00; margin-bottom: 35px; font-size: 32px; text-shadow: 0 0 20px rgba(200,0,0,0.8); }
        #pauseMenu button { background: #1a0000; color: #aaa; border: 1px solid #440000; padding: 12px 35px; margin: 10px auto; cursor: pointer; font-family: 'Courier New', monospace; font-size: 14px; transition: all 0.2s; display: block; width: 200px; }
        #pauseMenu button:hover { background: #330000; border-color: #a00; color: #fff; box-shadow: 0 0 20px rgba(200,0,0,0.5); }
        #credits { position: absolute; bottom: 15px; left: 50%; transform: translateX(-50%); font-size: 11px; color: #444; }
        #interaction { position: absolute; top: 75%; left: 50%; transform: translateX(-50%); background: rgba(10,0,0,0.95); padding: 10px 20px; border: 1px solid #660000; display: none; font-size: 13px; color: #ccc; box-shadow: 0 0 30px rgba(100,0,0,0.6); }
        #flashlightIndicator { position: absolute; bottom: 20px; left: 20px; background: rgba(10,0,0,0.9); padding: 8px 15px; border: 1px solid #440000; font-size: 11px; color: #888; box-shadow: 0 4px 30px rgba(100,0,0,0.5); }
        #crosshair { position: absolute; top: 50%; left: 50%; transform: translate(-50%,-50%); width: 3px; height: 3px; background: rgba(200,0,0,0.6); border-radius: 50%; box-shadow: 0 0 5px rgba(200,0,0,0.8); }
        #clickToStart { position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; background: linear-gradient(to bottom, #000000 0%, #0a0000 50%, #000000 100%); text-align: center; pointer-events: all; cursor: pointer; box-shadow: inset 0 0 200px rgba(0,0,0,0.9); display: flex; flex-direction: column; align-items: center; justify-content: center; z-index: 1000; }
        #clickToStart h2 { color: #c00; margin-bottom: 15px; font-size: 72px; text-shadow: 0 0 40px rgba(200,0,0,1), 0 0 80px rgba(200,0,0,0.8), 0 0 120px rgba(200,0,0,0.6); letter-spacing: 12px; font-weight: bold; animation: flicker 3s infinite; }
        @keyframes flicker { 0%, 100% { opacity: 1; text-shadow: 0 0 40px rgba(200,0,0,1), 0 0 80px rgba(200,0,0,0.8); } 50% { opacity: 0.95; text-shadow: 0 0 30px rgba(200,0,0,0.9), 0 0 60px rgba(200,0,0,0.6); } 75% { opacity: 1; } 76% { opacity: 0.9; } 77% { opacity: 1; } }
        #clickToStart .subtitle { color: #600; font-size: 16px; letter-spacing: 8px; margin-bottom: 60px; text-shadow: 0 0 15px rgba(100,0,0,0.8); text-transform: uppercase; }
        #clickToStart .creator { color: #400; font-size: 13px; letter-spacing: 4px; margin-bottom: 50px; text-shadow: 0 0 10px rgba(80,0,0,0.6); font-style: italic; }
        #clickToStart p { color: #777; margin: 8px 0; font-size: 14px; line-height: 1.8; }
        #clickToStart .controls { margin-top: 40px; margin-bottom: 50px; }
        #clickToStart .start { color: #c00; margin-top: 40px; font-size: 20px; animation: pulse 2s infinite; text-shadow: 0 0 25px rgba(200,0,0,0.9); letter-spacing: 4px; font-weight: bold; }
        @keyframes pulse { 0%, 100% { opacity: 0.6; } 50% { opacity: 1; } }
        #vignette { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; background: radial-gradient(circle at center, transparent 0%, transparent 40%, rgba(0,0,0,0.4) 70%, rgba(0,0,0,0.8) 100%); }
        #escapeScreen { position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; background: radial-gradient(circle, #ffffff 0%, #ffffee 30%, #ffddaa 60%, #000000 100%); display: none; flex-direction: column; align-items: center; justify-content: center; z-index: 2000; animation: fadeToWhite 3s; }
        @keyframes fadeToWhite { 0% { opacity: 0; } 100% { opacity: 1; } }
        #escapeScreen h1 { font-size: 64px; color: #000; text-shadow: 0 0 30px rgba(255,255,255,0.8); margin-bottom: 20px; animation: fadeIn 2s 1s backwards; }
        #escapeScreen p { font-size: 20px; color: #333; animation: fadeIn 2s 2s backwards; }
        @keyframes fadeIn { 0% { opacity: 0; transform: translateY(20px); } 100% { opacity: 1; transform: translateY(0); } }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>
    <div id="hud">
        <div id="vignette"></div>
        <div id="compass">N</div>
        <div id="inventory"><h3>INVENTORY</h3><div id="keyStatus">Key: ✗</div></div>
        <div id="flashlightIndicator">[F] FLASHLIGHT: OFF</div>
        <div id="objectives"><h3>OBJECTIVES</h3><ul><li id="obj1">Find the key</li><li id="obj2">Locate the red door</li><li id="obj3">Escape the basement</li></ul></div>
        <div id="map"><canvas id="mapCanvas" width="230" height="230"></canvas></div>
        <div id="crosshair"></div>
        <div id="interaction"></div>
        <div id="credits">Created by Zaydon</div>
        <div id="pauseMenu">
            <h2>PAUSED</h2>
            <button onclick="togglePause()">Resume</button>
            <button onclick="goToMenu()">Menu</button>
            <button onclick="location.reload()">Restart</button>
        </div>
        <div id="clickToStart" onclick="startGame()">
            <h2>BASEMENT</h2>
            <div class="subtitle">A HORROR EXPERIENCE</div>
            <div class="creator">By Zaydon</div>
            <div class="controls">
                <p>WASD - Move</p>
                <p>Mouse - Look Around</p>
                <p>E - Interact</p>
                <p>F - Flashlight</p>
                <p>ESC - Pause</p>
            </div>
            <p class="start">CLICK TO ENTER</p>
        </div>
    </div>
    <div id="escapeScreen">
        <h1>YOU ESCAPED</h1>
        <p>Game by Zaydon</p>
    </div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        let scene, camera, renderer, walls = [], keyMesh, doorLeft, doorRight, flashlight, keyLight;
        let hallway, stairs, exitLight;
        const canvas = document.getElementById('gameCanvas');
        const mapCanvas = document.getElementById('mapCanvas');
        const mapCtx = mapCanvas.getContext('2d');
        
        let keys = {}, isPaused = false, gameWon = false, gameStarted = false;
        let hasKey = false, doorOpening = false, doorOpenAmount = 0;
        let moveForward = false, moveBackward = false, moveLeft = false, moveRight = false;
        let velocity = new THREE.Vector3();
        let direction = new THREE.Vector3();
        let yaw = 0, pitch = 0;
        let lookingAtObject = null;
        
        const keySpawnLocations = [
            {x: -30, z: 15}, {x: 40, z: -20}, {x: -15, z: -30}, 
            {x: 25, z: 25}, {x: -40, z: -5}, {x: 35, z: 10},
            {x: -25, z: 30}, {x: 15, z: -25}, {x: -35, z: -25},
            {x: 45, z: 15}, {x: -10, z: 20}, {x: 20, z: -35}
        ];
        
        function init() {
            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x0a0a0a, 0.025);
            
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 150);
            camera.position.set(5, 1.7, 5);
            
            renderer = new THREE.WebGLRenderer({canvas, antialias: true});
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            
            // Larger floor
            const floorGeo = new THREE.PlaneGeometry(120, 100);
            const floorMat = new THREE.MeshStandardMaterial({color: 0x1a1a1a, roughness: 0.9});
            const floor = new THREE.Mesh(floorGeo, floorMat);
            floor.rotation.x = -Math.PI / 2;
            floor.receiveShadow = true;
            scene.add(floor);
            
            // Ceiling
            const ceiling = new THREE.Mesh(floorGeo, new THREE.MeshStandardMaterial({color: 0x0a0a0a}));
            ceiling.rotation.x = Math.PI / 2;
            ceiling.position.y = 4;
            scene.add(ceiling);
            
            // Walls - much bigger map with open spaces
            const wallMat = new THREE.MeshStandardMaterial({color: 0x2a2a2a, roughness: 0.95});
            const wallData = [
                // Outer walls
                {x: 0, z: -50, w: 120, h: 0.3}, {x: 0, z: 50, w: 120, h: 0.3},
                {x: -60, z: 0, w: 0.3, h: 100}, {x: 60, z: 0, w: 0.3, h: 100},
                // Inner maze walls with gaps
                {x: -30, z: -20, w: 0.3, h: 25}, {x: -15, z: 10, w: 0.3, h: 30},
                {x: 10, z: -15, w: 35, h: 0.3}, {x: 25, z: 15, w: 20, h: 0.3},
                {x: -40, z: 25, w: 15, h: 0.3}, {x: 35, z: -30, w: 0.3, h: 20},
                {x: -20, z: -35, w: 25, h: 0.3}, {x: 40, z: 20, w: 0.3, h: 25},
                {x: 0, z: 30, w: 20, h: 0.3}, {x: -45, z: -10, w: 0.3, h: 15}
            ];
            
            wallData.forEach(w => {
                const wall = new THREE.Mesh(new THREE.BoxGeometry(w.w, 4, w.h), wallMat);
                wall.position.set(w.x, 2, w.z);
                wall.castShadow = true;
                wall.receiveShadow = true;
                wall.userData.isWall = true;
                scene.add(wall);
                walls.push(wall);
            });
            
            // Door frame walls (create opening for door)
            const doorFrameLeft = new THREE.Mesh(new THREE.BoxGeometry(0.3, 4, 2), wallMat);
            doorFrameLeft.position.set(52, 2, -49.5);
            doorFrameLeft.castShadow = true;
            scene.add(doorFrameLeft);
            walls.push(doorFrameLeft);
            
            const doorFrameRight = new THREE.Mesh(new THREE.BoxGeometry(0.3, 4, 2), wallMat);
            doorFrameRight.position.set(60, 2, -49.5);
            doorFrameRight.castShadow = true;
            scene.add(doorFrameRight);
            walls.push(doorFrameRight);
            
            // Hallway after door - extended
            const hallwayFloor = new THREE.Mesh(new THREE.BoxGeometry(8, 0.1, 50), floorMat);
            hallwayFloor.position.set(56, 0, -45);
            hallwayFloor.receiveShadow = true;
            scene.add(hallwayFloor);
            
            const hallwayCeiling = new THREE.Mesh(new THREE.BoxGeometry(8, 0.1, 50), new THREE.MeshStandardMaterial({color: 0x0a0a0a}));
            hallwayCeiling.position.set(56, 4, -45);
            scene.add(hallwayCeiling);
            
            // Hallway walls
            const hallwayWallLeft = new THREE.Mesh(new THREE.BoxGeometry(0.3, 4, 50), wallMat);
            hallwayWallLeft.position.set(52, 2, -45);
            hallwayWallLeft.castShadow = true;
            hallwayWallLeft.userData.isWall = true;
            scene.add(hallwayWallLeft);
            walls.push(hallwayWallLeft);
            
            const hallwayWallRight = new THREE.Mesh(new THREE.BoxGeometry(0.3, 4, 50), wallMat);
            hallwayWallRight.position.set(60, 2, -45);
            hallwayWallRight.castShadow = true;
            hallwayWallRight.userData.isWall = true;
            scene.add(hallwayWallRight);
            walls.push(hallwayWallRight);
            
            // Stairs - moved further down hallway and added collision
            for(let i = 0; i < 12; i++) {
                const step = new THREE.Mesh(new THREE.BoxGeometry(8, 0.3, 1.5), new THREE.MeshStandardMaterial({color: 0x333333}));
                step.position.set(56, 0.15 + i * 0.3, -55 - i * 1.5);
                step.receiveShadow = true;
                step.castShadow = true;
                step.userData.isWall = true;
                scene.add(step);
                walls.push(step);
            }
            
            // Bright exit light - moved to end of stairs
            exitLight = new THREE.PointLight(0xffffee, 8, 25);
            exitLight.position.set(56, 5, -75);
            scene.add(exitLight);
            
            const exitGlow = new THREE.Mesh(
                new THREE.SphereGeometry(1.5, 16, 16),
                new THREE.MeshBasicMaterial({color: 0xffffee})
            );
            exitGlow.position.set(56, 4.5, -75);
            scene.add(exitGlow);
            
            // Door - FIXED positioning to properly block hallway
            const doorMat = new THREE.MeshStandardMaterial({color: 0x5a0000, roughness: 0.5, metalness: 0.3});
            doorLeft = new THREE.Mesh(new THREE.BoxGeometry(2, 3.5, 0.2), doorMat);
            doorRight = new THREE.Mesh(new THREE.BoxGeometry(2, 3.5, 0.2), doorMat);
            doorLeft.position.set(54, 1.75, -49.9);
            doorRight.position.set(58, 1.75, -49.9);
            doorLeft.castShadow = true;
            doorRight.castShadow = true;
            doorLeft.userData.isDoor = true;
            doorRight.userData.isDoor = true;
            doorLeft.userData.canInteract = true;
            doorRight.userData.canInteract = true;
            scene.add(doorLeft, doorRight);
            
            const doorLight = new THREE.PointLight(0x5a0000, 0.4, 10);
            doorLight.position.set(56, 2, -48);
            scene.add(doorLight);
            
            // Random key spawn - PROPER KEY MODEL
            const randomSpawn = keySpawnLocations[Math.floor(Math.random() * keySpawnLocations.length)];
            
            keyMesh = new THREE.Group();
            const keyMat = new THREE.MeshStandardMaterial({
                color: 0xffd700, 
                emissive: 0xffaa00, 
                emissiveIntensity: 0.8, 
                metalness: 0.9,
                roughness: 0.2
            });
            
            // Key shaft (long part)
            const shaft = new THREE.Mesh(new THREE.CylinderGeometry(0.04, 0.04, 0.8, 8), keyMat);
            shaft.rotation.z = Math.PI / 2;
            shaft.position.x = 0.2;
            keyMesh.add(shaft);
            
            // Key head/bow (round part you hold)
            const head = new THREE.Mesh(new THREE.TorusGeometry(0.15, 0.04, 8, 12), keyMat);
            head.rotation.y = Math.PI / 2;
            head.position.x = -0.2;
            keyMesh.add(head);
            
            // Key teeth (the part that goes in lock)
            const tooth1 = new THREE.Mesh(new THREE.BoxGeometry(0.08, 0.12, 0.04), keyMat);
            tooth1.position.set(0.5, -0.06, 0);
            keyMesh.add(tooth1);
            
            const tooth2 = new THREE.Mesh(new THREE.BoxGeometry(0.08, 0.08, 0.04), keyMat);
            tooth2.position.set(0.6, -0.04, 0);
            keyMesh.add(tooth2);
            
            const tooth3 = new THREE.Mesh(new THREE.BoxGeometry(0.06, 0.1, 0.04), keyMat);
            tooth3.position.set(0.55, -0.05, 0);
            keyMesh.add(tooth3);
            
            keyMesh.position.set(randomSpawn.x, 1, randomSpawn.z);
            keyMesh.castShadow = true;
            keyMesh.userData.canInteract = true;
            keyMesh.userData.isKey = true;
            keyMesh.rotation.x = Math.PI / 2;
            scene.add(keyMesh);
            
            keyLight = new THREE.PointLight(0xffdd00, 0.8, 6);
            keyLight.position.copy(keyMesh.position);
            scene.add(keyLight);
            
            // Ambient light - darker
            const ambient = new THREE.AmbientLight(0x404040, 0.3);
            scene.add(ambient);
            
            // Area lights - darker
            const areaLight1 = new THREE.PointLight(0x404040, 0.5, 18);
            areaLight1.position.set(10, 3, 0);
            scene.add(areaLight1);
            
            const areaLight2 = new THREE.PointLight(0x404040, 0.5, 18);
            areaLight2.position.set(-20, 3, 20);
            scene.add(areaLight2);
            
            const areaLight3 = new THREE.PointLight(0x404040, 0.5, 18);
            areaLight3.position.set(30, 3, -20);
            scene.add(areaLight3);
            
            // Flashlight
            flashlight = new THREE.SpotLight(0xffffee, 0, 30, Math.PI / 4.5, 0.3);
            flashlight.castShadow = true;
            flashlight.shadow.mapSize.width = 1024;
            flashlight.shadow.mapSize.height = 1024;
            flashlight.position.set(0, 0, 0);
            scene.add(flashlight);
            
            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            });
        }
        
        function startGame() {
            document.getElementById('clickToStart').style.display = 'none';
            gameStarted = true;
            canvas.requestPointerLock();
        }
        
        function goToMenu() {
            document.exitPointerLock();
            location.reload();
        }
        
        canvas.addEventListener('click', () => {
            if (gameStarted && !isPaused) canvas.requestPointerLock();
        });
        
        document.addEventListener('mousemove', e => {
            if (document.pointerLockElement === canvas && !isPaused) {
                yaw -= e.movementX * 0.002;
                pitch -= e.movementY * 0.002;
                pitch = Math.max(-Math.PI/3, Math.min(Math.PI/3, pitch));
            }
        });
        
        window.addEventListener('keydown', e => {
            switch(e.key.toLowerCase()) {
                case 'w': moveForward = true; break;
                case 's': moveBackward = true; break;
                case 'a': moveLeft = true; break;
                case 'd': moveRight = true; break;
                case 'e': keys['e'] = true; break;
            }
            if (e.key === 'Escape') togglePause();
            if (e.key.toLowerCase() === 'f') {
                flashlight.intensity = flashlight.intensity > 0 ? 0 : 4.5;
                document.getElementById('flashlightIndicator').textContent = `[F] FLASHLIGHT: ${flashlight.intensity > 0 ? 'ON' : 'OFF'}`;
            }
        });
        
        window.addEventListener('keyup', e => {
            switch(e.key.toLowerCase()) {
                case 'w': moveForward = false; break;
                case 's': moveBackward = false; break;
                case 'a': moveLeft = false; break;
                case 'd': moveRight = false; break;
                case 'e': keys['e'] = false; break;
            }
        });
        
        function togglePause() {
            if (!gameStarted) return;
            isPaused = !isPaused;
            document.getElementById('pauseMenu').style.display = isPaused ? 'block' : 'none';
            if (!isPaused) canvas.requestPointerLock();
            else document.exitPointerLock();
        }
        
        function checkCollision(newPos) {
            const playerBox = new THREE.Box3(
                new THREE.Vector3(newPos.x - 0.4, newPos.y - 1.7, newPos.z - 0.4),
                new THREE.Vector3(newPos.x + 0.4, newPos.y + 0.3, newPos.z + 0.4)
            );
            
            // Check all walls including stairs
            for (let wall of walls) {
                const wallBox = new THREE.Box3().setFromObject(wall);
                if (playerBox.intersectsBox(wallBox)) return true;
            }
            
            // Check door collision - only block if door isn't fully open
            if (!doorOpening || doorOpenAmount < 2) {
                if (doorLeft.visible) {
                    const leftBox = new THREE.Box3().setFromObject(doorLeft);
                    if (playerBox.intersectsBox(leftBox)) return true;
                }
                if (doorRight.visible) {
                    const rightBox = new THREE.Box3().setFromObject(doorRight);
                    if (playerBox.intersectsBox(rightBox)) return true;
                }
            }
            
            // Prevent player from going below ground or too high
            if (newPos.y < 1.7 || newPos.y > 10) return true;
            
            return false;
        }
        
        function checkLookingAt() {
            const raycaster = new THREE.Raycaster();
            raycaster.setFromCamera(new THREE.Vector2(0, 0), camera);
            
            const interactables = [keyMesh, doorLeft, doorRight].filter(obj => obj.visible && obj.userData.canInteract);
            const intersects = raycaster.intersectObjects(interactables, true);
            
            if (intersects.length > 0 && intersects[0].distance < 3) {
                lookingAtObject = intersects[0].object.parent && intersects[0].object.parent.userData.isKey 
                    ? intersects[0].object.parent 
                    : intersects[0].object;
                    
                if (lookingAtObject.userData.isKey || (lookingAtObject.parent && lookingAtObject.parent.userData.isKey)) {
                    document.getElementById('interaction').textContent = 'Press E to pick up key';
                    document.getElementById('interaction').style.display = 'block';
                } else if (lookingAtObject.userData.isDoor) {
                    if (hasKey && !doorOpening) {
                        document.getElementById('interaction').textContent = 'Press E to open door';
                        document.getElementById('interaction').style.display = 'block';
                    } else if (!hasKey) {
                        document.getElementById('interaction').textContent = 'Locked. Find the key.';
                        document.getElementById('interaction').style.display = 'block';
                    } else {
                        document.getElementById('interaction').style.display = 'none';
                    }
                }
            } else {
                lookingAtObject = null;
                document.getElementById('interaction').style.display = 'none';
            }
        }
        
        function update() {
            if (isPaused || !gameStarted) return;
            
            camera.rotation.order = 'YXZ';
            camera.rotation.y = yaw;
            camera.rotation.x = pitch;
            
            direction.set(0, 0, 0);
            if (moveForward) direction.z -= 1;
            if (moveBackward) direction.z += 1;
            if (moveLeft) direction.x -= 1;
            if (moveRight) direction.x += 1;
            
            if (direction.length() > 0) {
                direction.normalize();
                direction.applyQuaternion(camera.quaternion);
                direction.y = 0;
                direction.normalize();
                
                const newPos = camera.position.clone().add(direction.multiplyScalar(0.1));
                if (!checkCollision(newPos)) {
                    camera.position.copy(newPos);
                }
            }
            
            flashlight.position.copy(camera.position);
            flashlight.target.position.copy(camera.position).add(
                new THREE.Vector3(0, 0, -1).applyQuaternion(camera.quaternion)
            );
            flashlight.target.updateMatrixWorld();
            
            checkLookingAt();
            
            if (keys['e'] && lookingAtObject && !keys['e_used']) {
                keys['e_used'] = true;
                
                const targetObj = lookingAtObject.userData ? lookingAtObject : lookingAtObject.parent;
                
                if ((targetObj.userData.isKey || (targetObj.parent && targetObj.parent.userData.isKey)) && !hasKey) {
                    hasKey = true;
                    keyMesh.visible = false;
                    keyLight.visible = false;
                    scene.remove(keyLight);
                    document.getElementById('keyStatus').textContent = 'Key: ✓';
                    document.getElementById('obj1').classList.add('complete');
                    document.getElementById('interaction').style.display = 'none';
                    keyMesh.userData.canInteract = false;
                } else if (lookingAtObject.userData.isDoor && hasKey && !doorOpening) {
                    doorOpening = true;
                    document.getElementById('obj2').classList.add('complete');
                    doorLeft.userData.canInteract = false;
                    doorRight.userData.canInteract = false;
                }
                
                setTimeout(() => keys['e_used'] = false, 300);
            }
            
            // DOOR OPENING ANIMATION - FIXED
            if (doorOpening) {
                doorOpenAmount += 0.04;
                doorLeft.position.x = 54 - doorOpenAmount * 2;
                doorRight.position.x = 58 + doorOpenAmount * 2;
                if (doorOpenAmount >= 2) {
                    doorLeft.visible = false;
                    doorRight.visible = false;
                }
            }
            
            // Check if player reached exit light
            const exitDist = camera.position.distanceTo(exitLight.position);
            if (exitDist < 4 && !gameWon) {
                gameWon = true;
                document.getElementById('obj3').classList.add('complete');
                document.getElementById('escapeScreen').style.display = 'flex';
                document.exitPointerLock();
                setTimeout(() => {
                    location.reload();
                }, 5000);
            }
            
            // KEY ROTATION - FIXED
            if (keyMesh.visible) {
                keyMesh.rotation.z += 0.02;
            }
            
            let angle = ((-yaw * 180 / Math.PI) + 90) % 360;
            if (angle < 0) angle += 360;
            let dir2 = 'N';
            if (angle > 45 && angle <= 135) dir2 = 'E';
            else if (angle > 135 && angle <= 225) dir2 = 'S';
            else if (angle > 225 && angle <= 315) dir2 = 'W';
            document.getElementById('compass').textContent = dir2;
            
            // Draw map
            const scale = 1.9;
            mapCtx.fillStyle = '#050000';
            mapCtx.fillRect(0, 0, 230, 230);
            mapCtx.strokeStyle = '#2a1010';
            mapCtx.lineWidth = 4;
            walls.forEach(w => {
                const box = new THREE.Box3().setFromObject(w);
                const size = box.getSize(new THREE.Vector3());
                mapCtx.fillStyle = '#1a0a0a';
                mapCtx.fillRect((w.position.x+60)*scale - size.x*scale/2, (w.position.z+50)*scale - size.z*scale/2, size.x*scale, size.z*scale);
            });
            if (doorLeft.visible || doorRight.visible) {
                mapCtx.fillStyle = doorOpening ? '#ff4444' : '#8a0000';
                mapCtx.fillRect((doorLeft.position.x+60)*scale, (doorLeft.position.z+50)*scale, (doorRight.position.x - doorLeft.position.x)*scale, 3);
            }
            mapCtx.fillStyle = '#00ff00';
            mapCtx.beginPath();
            mapCtx.arc((camera.position.x+60)*scale, (camera.position.z+50)*scale, 5, 0, Math.PI*2);
            mapCtx.fill();
            mapCtx.strokeStyle = '#00ff00';
            mapCtx.lineWidth = 2;
            mapCtx.beginPath();
            mapCtx.moveTo((camera.position.x+60)*scale, (camera.position.z+50)*scale);
            mapCtx.lineTo(
                (camera.position.x+60)*scale + Math.cos(-yaw + Math.PI/2) * 15,
                (camera.position.z+50)*scale + Math.sin(-yaw + Math.PI/2) * 15
            );
            mapCtx.stroke();
        }
        
        function animate() {
            requestAnimationFrame(animate);
            update();
            renderer.render(scene, camera);
        }
        
        init();
        animate();
    </script>
</body>
</html>
