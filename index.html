<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BASEMENT -By Zaydon</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: 'Courier New', monospace; overflow: hidden; background: #000; }
        #gameCanvas { display: block; cursor: crosshair; }
        #hud { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; color: #fff; }
        #inventory { position: absolute; top: 20px; right: 20px; background: rgba(10,0,0,0.9); padding: 15px 20px; border: 1px solid #440000; font-size: 14px; }
        #compass { position: absolute; top: 20px; left: 20px; width: 70px; height: 70px; background: rgba(10,0,0,0.9); border: 1px solid #440000; border-radius: 50%; display: flex; align-items: center; justify-content: center; font-size: 24px; font-weight: bold; color: #a00; }
        #objectives { position: absolute; top: 110px; left: 20px; background: rgba(10,0,0,0.9); padding: 15px 20px; border: 1px solid #440000; max-width: 260px; }
        #objectives ul { list-style: none; padding-left: 0; }
        #objectives li { margin: 6px 0; font-size: 13px; color: #999; }
        #objectives li.complete { text-decoration: line-through; color: #0a0; }
        #map { position: absolute; bottom: 20px; right: 20px; width: 250px; height: 250px; background: rgba(10,0,0,0.9); border: 1px solid #440000; padding: 10px; }
        #interaction { position: absolute; top: 75%; left: 50%; transform: translateX(-50%); background: rgba(10,0,0,0.95); padding: 10px 20px; border: 1px solid #660000; display: none; font-size: 13px; color: #ccc; }
        #flashlightIndicator { position: absolute; bottom: 20px; left: 20px; background: rgba(10,0,0,0.9); padding: 8px 15px; border: 1px solid #440000; font-size: 11px; color: #888; }
        #crosshair { position: absolute; top: 50%; left: 50%; transform: translate(-50%,-50%); width: 3px; height: 3px; background: rgba(200,0,0,0.6); border-radius: 50%; }
        #monsterWarning { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); background: rgba(100,0,0,0.9); padding: 20px 40px; border: 2px solid #f00; display: none; font-size: 24px; color: #fff; animation: warningBlink 0.5s infinite; }
        @keyframes warningBlink { 0%, 100% { opacity: 0.8; } 50% { opacity: 1; } }
        
        #startMenu { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: #000; display: flex; flex-direction: column; align-items: center; justify-content: center; z-index: 1000; pointer-events: all; }
        #startMenu h1 { color: #c00; font-size: 64px; margin-bottom: 20px; letter-spacing: 12px; text-shadow: 0 0 20px #c00; }
        #startMenu p { color: #666; font-size: 14px; margin-bottom: 40px; }
        #startMenu button { background: #1a0000; color: #aaa; border: 2px solid #440000; padding: 15px 50px; cursor: pointer; font-family: 'Courier New', monospace; font-size: 18px; transition: all 0.3s; }
        #startMenu button:hover { background: #330000; border-color: #c00; color: #fff; box-shadow: 0 0 20px #c00; }
        
        #loadingScreen { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: #000; display: none; flex-direction: column; align-items: center; justify-content: center; z-index: 1001; }
        #loadingScreen h1 { color: #c00; font-size: 48px; margin-bottom: 30px; letter-spacing: 8px; }
        #loadingBar { width: 300px; height: 6px; background: #222; border: 1px solid #440000; margin-bottom: 20px; }
        #loadingProgress { width: 0%; height: 100%; background: linear-gradient(90deg, #500, #c00); transition: width 0.3s; }
        #loadingText { color: #666; font-size: 14px; margin-bottom: 40px; }
        
        #flashlightPrompt { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.95); display: none; flex-direction: column; align-items: center; justify-content: center; z-index: 1002; pointer-events: all; }
        #flashlightPrompt h2 { color: #c00; font-size: 36px; margin-bottom: 30px; }
        #flashlightPrompt p { color: #aaa; font-size: 18px; margin-bottom: 50px; }
        #pressF { color: #fff; font-size: 24px; animation: fadeInOut 2s infinite; text-align: center; border: 2px solid #c00; padding: 20px 40px; background: rgba(100,0,0,0.3); }
        @keyframes fadeInOut { 0%, 100% { opacity: 0.5; } 50% { opacity: 1; } }
        
        #jumpscare { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: #000; display: none; z-index: 2000; align-items: center; justify-content: center; }
        #jumpscare img { max-width: 100%; max-height: 100%; object-fit: contain; animation: jumpscareShake 0.1s infinite; }
        @keyframes jumpscareShake { 0%, 100% { transform: translate(0, 0) scale(1.1); } 25% { transform: translate(-10px, 10px) scale(1.15); } 50% { transform: translate(10px, -10px) scale(1.1); } 75% { transform: translate(-10px, -10px) scale(1.15); } }
        
        #winScreen { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: #000; display: none; align-items: center; justify-content: center; z-index: 2000; opacity: 0; transition: opacity 2s; }
        #winScreen h1 { color: #0f0; font-size: 72px; letter-spacing: 16px; text-shadow: 0 0 30px #0f0; }
        #winScreen.show { opacity: 1; }
        
        #pauseMenu { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); background: rgba(0,0,0,0.95); padding: 40px; border: 2px solid #c00; color: #aaa; text-align: center; pointer-events: all; display: none; z-index: 999; }
        #pauseMenu h2 { color: #c00; margin-bottom: 20px; }
        #pauseMenu button { background: #1a0000; color: #aaa; border: 1px solid #440000; padding: 12px 35px; margin: 10px; cursor: pointer; font-family: 'Courier New', monospace; font-size: 14px; }
        #pauseMenu button:hover { background: #330000; border-color: #a00; color: #fff; }
    </style>
</head>
<body>
    <div id="startMenu">
        <h1>BASEMENT</h1>
        <p>BY ZAYDON</p>
        <button onclick="beginLoading()">START GAME</button>
    </div>
    
    <div id="loadingScreen">
        <h1>BASEMENT</h1>
        <div id="loadingBar"><div id="loadingProgress"></div></div>
        <div id="loadingText">LOADING...</div>
    </div>
    
    <div id="flashlightPrompt">
        <h2>CONTROLS</h2>
        <p>WASD - Move | Mouse - Look | E - Interact</p>
        <div id="pressF">PRESS [F] FOR FLASHLIGHT</div>
    </div>
    
    <div id="jumpscare"><img id="jumpscareImg" src="" alt=""></div>
    
    <div id="winScreen"><h1>YOU WIN!</h1></div>
    
    <canvas id="gameCanvas"></canvas>
    
    <div id="hud">
        <div id="compass">N</div>
        <div id="inventory"><div id="keyStatus">Key: ✗</div></div>
        <div id="flashlightIndicator">[F] FLASHLIGHT: OFF</div>
        <div id="objectives"><ul><li id="obj1">Find the key</li><li id="obj2">Locate the red door</li><li id="obj3">Escape the basement</li></ul></div>
        <div id="map"><canvas id="mapCanvas" width="230" height="230"></canvas></div>
        <div id="crosshair"></div>
        <div id="interaction"></div>
        <div id="monsterWarning">⚠ SOMETHING IS HUNTING YOU ⚠</div>
    </div>
    
    <div id="pauseMenu">
        <h2>GAME PAUSED</h2>
        <p>WASD - Move | Mouse - Look | E - Interact | F - Flashlight</p>
        <button onclick="resumeGame()">RESUME</button>
        <button onclick="resetToMenu()">RETURN TO MENU</button>
    </div>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        let scene, camera, renderer, walls = [], keyMesh, doorLeft, doorRight, flashlight, keyLight;
        let stairs = [], exitLight, monster, monsterLight;
        const canvas = document.getElementById('gameCanvas');
        const mapCanvas = document.getElementById('mapCanvas');
        const mapCtx = mapCanvas.getContext('2d');
        
        let gameStarted = false, hasKey = false, doorOpening = false, doorOpenAmount = 0;
        let doorAnimationComplete = false;
        let moveForward = false, moveBackward = false, moveLeft = false, moveRight = false;
        let yaw = 0, pitch = 0, lookingAtObject = null;
        let flashlightOn = false;
        let monsterSpeed = 0.065, monsterActivated = false, monsterActivationTimer = 0;
        let loadingComplete = false;
        let monsterTexture = 'https://miro.medium.com/v2/resize:fit:1400/1*koUr4odA91ARVyQzpIQwjg.jpeg';
        let awaitingFlashlight = false;
        const startPosition = { x: 5, y: 1.7, z: 5 };
        const startRotation = { yaw: 0, pitch: 0 };
        
        // Loading sequence
        let loadProgress = 0;
        const loadingScreen = document.getElementById('loadingScreen');
        const loadingProgress = document.getElementById('loadingProgress');
        const loadingText = document.getElementById('loadingText');
        const flashlightPrompt = document.getElementById('flashlightPrompt');
        const startMenu = document.getElementById('startMenu');
        
        function beginLoading() {
            startMenu.style.display = 'none';
            loadingScreen.style.display = 'flex';
            updateLoading();
        }
        
        function updateLoading() {
            loadProgress += 2;
            loadingProgress.style.width = loadProgress + '%';
            
            if (loadProgress < 100) {
                setTimeout(updateLoading, 30 + Math.random() * 40);
            } else {
                loadingText.textContent = 'COMPLETE';
                setTimeout(() => {
                    loadingScreen.style.display = 'none';
                    flashlightPrompt.style.display = 'flex';
                    awaitingFlashlight = true;
                }, 1000);
            }
        }
        
        function init() {
            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x0a0a0a, 0.025);
            
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 150);
            camera.position.set(startPosition.x, startPosition.y, startPosition.z);
            
            renderer = new THREE.WebGLRenderer({canvas, antialias: true});
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            
            // Floor
            const floorGeo = new THREE.PlaneGeometry(120, 100);
            const floor = new THREE.Mesh(floorGeo, new THREE.MeshStandardMaterial({color: 0x1a1a1a}));
            floor.rotation.x = -Math.PI / 2;
            floor.receiveShadow = true;
            scene.add(floor);
            
            // Ceiling
            const ceiling = new THREE.Mesh(floorGeo, new THREE.MeshStandardMaterial({color: 0x0a0a0a}));
            ceiling.rotation.x = Math.PI / 2;
            ceiling.position.y = 4;
            scene.add(ceiling);
            
            // Walls
            const wallMat = new THREE.MeshStandardMaterial({color: 0x2a2a2a});
            const wallData = [
                {x: -4.5, z: -50, w: 111, h: 0.3}, {x: 85.5, z: -50, w: 49, h: 0.3},
                {x: 0, z: 50, w: 120, h: 0.3}, {x: -60, z: 0, w: 0.3, h: 100}, {x: 60, z: 0, w: 0.3, h: 100},
                {x: -30, z: -20, w: 0.3, h: 25}, {x: -15, z: 10, w: 0.3, h: 30},
                {x: 10, z: -15, w: 35, h: 0.3}, {x: 25, z: 15, w: 20, h: 0.3},
                {x: -40, z: 25, w: 15, h: 0.3}, {x: 35, z: -30, w: 0.3, h: 20}
            ];
            
            wallData.forEach(w => {
                const wall = new THREE.Mesh(new THREE.BoxGeometry(w.w, 4, w.h), wallMat);
                wall.position.set(w.x, 2, w.z);
                wall.castShadow = true;
                wall.userData.isWall = true;
                scene.add(wall);
                walls.push(wall);
            });
            
            // Door frames
            const doorFrameLeft = new THREE.Mesh(new THREE.BoxGeometry(0.3, 4, 2), wallMat);
            doorFrameLeft.position.set(51, 2, -49.5);
            doorFrameLeft.userData.isWall = true;
            scene.add(doorFrameLeft);
            walls.push(doorFrameLeft);
            
            const doorFrameRight = new THREE.Mesh(new THREE.BoxGeometry(0.3, 4, 2), wallMat);
            doorFrameRight.position.set(61, 2, -49.5);
            doorFrameRight.userData.isWall = true;
            scene.add(doorFrameRight);
            walls.push(doorFrameRight);
            
            // Hallway
            const hallwayFloor = new THREE.Mesh(new THREE.BoxGeometry(9.8, 0.1, 15), new THREE.MeshStandardMaterial({color: 0x1a1a1a}));
            hallwayFloor.position.set(56, 0, -60);
            scene.add(hallwayFloor);
            
            const hallwayWallLeft = new THREE.Mesh(new THREE.BoxGeometry(0.3, 4, 15), wallMat);
            hallwayWallLeft.position.set(51.1, 2, -60);
            hallwayWallLeft.userData.isWall = true;
            scene.add(hallwayWallLeft);
            walls.push(hallwayWallLeft);
            
            const hallwayWallRight = new THREE.Mesh(new THREE.BoxGeometry(0.3, 4, 15), wallMat);
            hallwayWallRight.position.set(60.9, 2, -60);
            hallwayWallRight.userData.isWall = true;
            scene.add(hallwayWallRight);
            walls.push(hallwayWallRight);
            
            // Stairs
            for(let i = 0; i < 20; i++) {
                const step = new THREE.Mesh(new THREE.BoxGeometry(9.8, 0.4, 1.5), new THREE.MeshStandardMaterial({color: 0x555555}));
                step.position.set(56, 0 + i * 0.5, -68 - i * 1.5);
                step.userData.isStair = true;
                scene.add(step);
                stairs.push(step);
            }
            
            // Stair walls
            const stairWallLeft = new THREE.Mesh(new THREE.BoxGeometry(0.3, 12, 32), wallMat);
            stairWallLeft.position.set(51.1, 6, -78);
            stairWallLeft.userData.isWall = true;
            scene.add(stairWallLeft);
            walls.push(stairWallLeft);
            
            const stairWallRight = new THREE.Mesh(new THREE.BoxGeometry(0.3, 12, 32), wallMat);
            stairWallRight.position.set(60.9, 6, -78);
            stairWallRight.userData.isWall = true;
            scene.add(stairWallRight);
            walls.push(stairWallRight);
            
            // Exit light
            exitLight = new THREE.PointLight(0xffff66, 50, 20);
            exitLight.position.set(56, 10, -100);
            scene.add(exitLight);
            
            const exitGlow = new THREE.Mesh(
                new THREE.SphereGeometry(3, 32, 32),
                new THREE.MeshBasicMaterial({color: 0xffff66, transparent: true, opacity: 0.95})
            );
            exitGlow.position.set(56, 10, -100);
            scene.add(exitGlow);
            
            // Doors - taller
            const doorMat = new THREE.MeshStandardMaterial({color: 0x5a0000});
            doorLeft = new THREE.Mesh(new THREE.BoxGeometry(4.9, 3.8, 0.2), doorMat);
            doorRight = new THREE.Mesh(new THREE.BoxGeometry(4.9, 3.8, 0.2), doorMat);
            doorLeft.position.set(53.55, 1.9, -49.9);
            doorRight.position.set(58.45, 1.9, -49.9);
            doorLeft.userData.isDoor = true;
            doorRight.userData.isDoor = true;
            doorLeft.userData.canInteract = true;
            doorRight.userData.canInteract = true;
            scene.add(doorLeft, doorRight);
            
            // Key
            keyMesh = new THREE.Group();
            const keyMat = new THREE.MeshStandardMaterial({color: 0xffd700, emissive: 0xffaa00, emissiveIntensity: 0.8});
            const shaft = new THREE.Mesh(new THREE.CylinderGeometry(0.04, 0.04, 0.8, 8), keyMat);
            shaft.rotation.z = Math.PI / 2;
            shaft.position.x = 0.2;
            keyMesh.add(shaft);
            
            const head = new THREE.Mesh(new THREE.TorusGeometry(0.15, 0.04, 8, 12), keyMat);
            head.rotation.y = Math.PI / 2;
            head.position.x = -0.2;
            keyMesh.add(head);
            
            keyMesh.position.set(-30, 1, 15);
            keyMesh.userData.canInteract = true;
            keyMesh.userData.isKey = true;
            keyMesh.rotation.x = Math.PI / 2;
            scene.add(keyMesh);
            
            keyLight = new THREE.PointLight(0xffdd00, 0.8, 6);
            keyLight.position.copy(keyMesh.position);
            scene.add(keyLight);
            
            // Monster with image texture
            monster = new THREE.Group();
            
            const textureLoader = new THREE.TextureLoader();
            textureLoader.crossOrigin = 'anonymous';
            
            const texture = textureLoader.load(monsterTexture);
            const monsterMaterial = new THREE.SpriteMaterial({ 
                map: texture,
                transparent: true,
                opacity: 0.95
            });
            const monsterSprite = new THREE.Sprite(monsterMaterial);
            monsterSprite.scale.set(3, 4, 1);
            monsterSprite.position.y = 2;
            monster.add(monsterSprite);
            monster.position.set(-45, 0, -40);
            scene.add(monster);
            
            monsterLight = new THREE.PointLight(0xff0000, 1.5, 8);
            monsterLight.position.copy(monster.position);
            monsterLight.position.y = 1.5;
            scene.add(monsterLight);
            
            // Lights
            const ambient = new THREE.AmbientLight(0x404040, 0.3);
            scene.add(ambient);
            
            const areaLight1 = new THREE.PointLight(0x404040, 0.5, 18);
            areaLight1.position.set(10, 3, 0);
            scene.add(areaLight1);
            
            // Flashlight
            flashlight = new THREE.SpotLight(0xffffee, 0, 30, Math.PI / 4.5, 0.3);
            flashlight.castShadow = true;
            scene.add(flashlight);
            
            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            });
        }
        
        function startGame() {
            flashlightPrompt.style.display = 'none';
            gameStarted = true;
            awaitingFlashlight = false;
            flashlightOn = true;
            flashlight.intensity = 4.5;
            document.getElementById('flashlightIndicator').textContent = '[F] FLASHLIGHT: ON';
            canvas.requestPointerLock();
        }
        
        function resumeGame() {
            document.getElementById('pauseMenu').style.display = 'none';
            canvas.requestPointerLock();
        }
        
        function resetToMenu() {
            // Reset all game state
            gameStarted = false;
            hasKey = false;
            doorOpening = false;
            doorOpenAmount = 0;
            doorAnimationComplete = false;
            flashlightOn = false;
            monsterActivated = false;
            monsterActivationTimer = 0;
            loadProgress = 0;
            awaitingFlashlight = false;
            
            // Reset positions
            camera.position.set(startPosition.x, startPosition.y, startPosition.z);
            yaw = startRotation.yaw;
            pitch = startRotation.pitch;
            monster.position.set(-45, 0, -40);
            
            // Reset door positions
            doorLeft.position.x = 53.55;
            doorRight.position.x = 58.45;
            doorLeft.visible = true;
            doorRight.visible = true;
            
            // Reset key
            keyMesh.visible = true;
            keyLight.visible = true;
            
            // Reset objectives
            document.getElementById('obj1').classList.remove('complete');
            document.getElementById('obj2').classList.remove('complete');
            document.getElementById('obj3').classList.remove('complete');
            document.getElementById('keyStatus').textContent = 'Key: ✗';
            
            // Reset flashlight
            flashlight.intensity = 0;
            document.getElementById('flashlightIndicator').textContent = '[F] FLASHLIGHT: OFF';
            
            // Hide warnings
            document.getElementById('monsterWarning').style.display = 'none';
            document.getElementById('interaction').style.display = 'none';
            
            // Exit pointer lock
            document.exitPointerLock();
            
            // Show start menu
            startMenu.style.display = 'flex';
        }
        
        canvas.addEventListener('click', () => {
            if (gameStarted && document.getElementById('pauseMenu').style.display !== 'block') {
                canvas.requestPointerLock();
            }
        });
        
        document.addEventListener('mousemove', e => {
            if (document.pointerLockElement === canvas && gameStarted) {
                yaw -= e.movementX * 0.002;
                pitch -= e.movementY * 0.002;
                pitch = Math.max(-Math.PI/3, Math.min(Math.PI/3, pitch));
            }
        });
        
        window.addEventListener('keydown', e => {
            if (awaitingFlashlight && e.key.toLowerCase() === 'f') {
                startGame();
                return;
            }
            
            if (!gameStarted) return;
            
            switch(e.key.toLowerCase()) {
                case 'w': moveForward = true; break;
                case 's': moveBackward = true; break;
                case 'a': moveLeft = true; break;
                case 'd': moveRight = true; break;
                case 'e': interact(); break;
                case 'f': 
                    flashlightOn = !flashlightOn;
                    flashlight.intensity = flashlightOn ? 4.5 : 0;
                    document.getElementById('flashlightIndicator').textContent = `[F] FLASHLIGHT: ${flashlightOn ? 'ON' : 'OFF'}`;
                    break;
                case 'escape':
                    document.getElementById('pauseMenu').style.display = 'block';
                    document.exitPointerLock();
                    break;
            }
        });
        
        window.addEventListener('keyup', e => {
            switch(e.key.toLowerCase()) {
                case 'w': moveForward = false; break;
                case 's': moveBackward = false; break;
                case 'a': moveLeft = false; break;
                case 'd': moveRight = false; break;
            }
        });
        
        function interact() {
            if (lookingAtObject) {
                if (lookingAtObject.userData.isKey && !hasKey) {
                    hasKey = true;
                    keyMesh.visible = false;
                    keyLight.visible = false;
                    document.getElementById('keyStatus').textContent = 'Key: ✓';
                    document.getElementById('obj1').classList.add('complete');
                } else if (lookingAtObject.userData.isDoor && hasKey && !doorOpening) {
                    doorOpening = true;
                    document.getElementById('obj2').classList.add('complete');
                }
            }
        }
        
        function checkCollision(newPos) {
            const playerBox = new THREE.Box3(
                new THREE.Vector3(newPos.x - 0.4, newPos.y - 1.7, newPos.z - 0.4),
                new THREE.Vector3(newPos.x + 0.4, newPos.y + 0.3, newPos.z + 0.4)
            );
            
            for (let wall of walls) {
                const wallBox = new THREE.Box3().setFromObject(wall);
                if (playerBox.intersectsBox(wallBox)) return true;
            }
            
            if (!doorAnimationComplete) {
                if (doorLeft.visible) {
                    const leftBox = new THREE.Box3().setFromObject(doorLeft);
                    if (playerBox.intersectsBox(leftBox)) return true;
                }
                if (doorRight.visible) {
                    const rightBox = new THREE.Box3().setFromObject(doorRight);
                    if (playerBox.intersectsBox(rightBox)) return true;
                }
            }
            
            return false;
        }
        
        function getStairHeight(pos) {
            for (let step of stairs) {
                const stepBox = new THREE.Box3().setFromObject(step);
                if (pos.x >= stepBox.min.x && pos.x <= stepBox.max.x &&
                    pos.z >= stepBox.min.z && pos.z <= stepBox.max.z) {
                    return stepBox.max.y;
                }
            }
            return null;
        }
        
        function triggerJumpscare() {
            const jumpscareDiv = document.getElementById('jumpscare');
            const jumpscareImg = document.getElementById('jumpscareImg');
            jumpscareImg.src = monsterTexture;
            jumpscareDiv.style.display = 'flex';
            
            if (navigator.vibrate) {
                navigator.vibrate([100, 50, 100, 50, 100]);
            }
            
            setTimeout(() => {
                jumpscareDiv.style.display = 'none';
                alert('YOU DIED! reload to play again the ok is lowkey buggy.');
                resetToMenu();
            }, 2000);
        }
        
        function updateMonster() {
            if (!monsterActivated) {
                monsterActivationTimer++;
                if (monsterActivationTimer > 180) {
                    monsterActivated = true;
                    document.getElementById('monsterWarning').style.display = 'block';
                    setTimeout(() => {
                        document.getElementById('monsterWarning').style.display = 'none';
                    }, 3000);
                }
                return;
            }
            
            const dirToPlayer = new THREE.Vector3()
                .subVectors(camera.position, monster.position)
                .normalize();
            
            monster.position.x += dirToPlayer.x * monsterSpeed;
            monster.position.z += dirToPlayer.z * monsterSpeed;
            
            monsterLight.position.copy(monster.position);
            monsterLight.position.y = 1.5;
            
            const glowPulse = Math.sin(Date.now() * 0.005) * 0.5 + 1;
            monsterLight.intensity = 1 + glowPulse;
            
            const angle = Math.atan2(dirToPlayer.x, dirToPlayer.z);
            monster.rotation.y = angle;
            
            const distToPlayer = monster.position.distanceTo(camera.position);
            if (distToPlayer < 2) {
                triggerJumpscare();
            }
        }
        
        function checkLookingAt() {
            const raycaster = new THREE.Raycaster();
            raycaster.setFromCamera(new THREE.Vector2(0, 0), camera);
            
            const interactables = [keyMesh, doorLeft, doorRight].filter(obj => obj.visible && obj.userData.canInteract);
            const intersects = raycaster.intersectObjects(interactables, true);
            
            if (intersects.length > 0 && intersects[0].distance < 3) {
                lookingAtObject = intersects[0].object.parent && intersects[0].object.parent.userData.isKey 
                    ? intersects[0].object.parent 
                    : intersects[0].object;
                    
                if (lookingAtObject.userData.isKey) {
                    document.getElementById('interaction').textContent = 'Press E to pick up key';
                    document.getElementById('interaction').style.display = 'block';
                } else if (lookingAtObject.userData.isDoor) {
                    if (hasKey && !doorOpening) {
                        document.getElementById('interaction').textContent = 'Press E to open door';
                        document.getElementById('interaction').style.display = 'block';
                    } else if (!hasKey) {
                        document.getElementById('interaction').textContent = 'Locked. Find the key.';
                        document.getElementById('interaction').style.display = 'block';
                    } else {
                        document.getElementById('interaction').style.display = 'none';
                    }
                }
            } else {
                lookingAtObject = null;
                document.getElementById('interaction').style.display = 'none';
            }
        }
        
        function update() {
            if (!gameStarted) return;
            if (document.getElementById('pauseMenu').style.display === 'block') return;
            
            camera.rotation.order = 'YXZ';
            camera.rotation.y = yaw;
            camera.rotation.x = pitch;
            
            const direction = new THREE.Vector3();
            if (moveForward) direction.z -= 1;
            if (moveBackward) direction.z += 1;
            if (moveLeft) direction.x -= 1;
            if (moveRight) direction.x += 1;
            
            if (direction.length() > 0) {
                direction.normalize();
                direction.applyQuaternion(camera.quaternion);
                direction.y = 0;
                direction.normalize();
                
                const newPos = camera.position.clone().add(direction.multiplyScalar(0.1));
                const stairHeight = getStairHeight(newPos);
                if (stairHeight !== null) newPos.y = stairHeight + 1.7;
                
                if (!checkCollision(newPos)) camera.position.copy(newPos);
            }
            
            flashlight.position.copy(camera.position);
            flashlight.target.position.copy(camera.position).add(
                new THREE.Vector3(0, 0, -1).applyQuaternion(camera.quaternion)
            );
            flashlight.target.updateMatrixWorld();
            
            checkLookingAt();
            updateMonster();
            
            if (doorOpening && !doorAnimationComplete) {
                doorOpenAmount += 0.02;
                if (doorOpenAmount >= 1) {
                    doorOpenAmount = 1;
                    doorAnimationComplete = true;
                }
                const eased = 1 - Math.pow(1 - doorOpenAmount, 3);
                const maxAngle = Math.PI / 2;
                
                // Move doors to the sides
                doorLeft.position.x = 53.55 - (eased * 2.5);
                doorRight.position.x = 58.45 + (eased * 2.5);
            }
            
            const exitDist = camera.position.distanceTo(exitLight.position);
            if (exitDist < 6) {
                document.getElementById('obj3').classList.add('complete');
                const winScreen = document.getElementById('winScreen');
                winScreen.style.display = 'flex';
                setTimeout(() => {
                    winScreen.classList.add('show');
                }, 50);
                setTimeout(() => {
                    winScreen.classList.remove('show');
                    setTimeout(() => {
                        winScreen.style.display = 'none';
                        resetToMenu();
                    }, 2000);
                }, 3000);
            }
            
            if (keyMesh.visible) keyMesh.rotation.z += 0.02;
            
            let angle = ((-yaw * 180 / Math.PI) + 90) % 360;
            if (angle < 0) angle += 360;
            let dir = 'N';
            if (angle > 45 && angle <= 135) dir = 'E';
            else if (angle > 135 && angle <= 225) dir = 'S';
            else if (angle > 225 && angle <= 315) dir = 'W';
            document.getElementById('compass').textContent = dir;
            
            // Draw map
            const scale = 1.9;
            mapCtx.fillStyle = '#050000';
            mapCtx.fillRect(0, 0, 230, 230);
            
            walls.forEach(w => {
                const box = new THREE.Box3().setFromObject(w);
                const size = box.getSize(new THREE.Vector3());
                const center = box.getCenter(new THREE.Vector3());
                mapCtx.fillStyle = '#3a2020';
                mapCtx.fillRect(
                    (center.x + 60) * scale - (size.x * scale) / 2,
                    (center.z + 50) * scale - (size.z * scale) / 2,
                    size.x * scale,
                    size.z * scale
                );
            });
            
            if (monsterActivated) {
                mapCtx.fillStyle = '#ff0000';
                mapCtx.beginPath();
                mapCtx.arc((monster.position.x+60)*scale, (monster.position.z+50)*scale, 5, 0, Math.PI*2);
                mapCtx.fill();
            }
            
            mapCtx.fillStyle = '#00ff00';
            mapCtx.beginPath();
            mapCtx.arc((camera.position.x+60)*scale, (camera.position.z+50)*scale, 4, 0, Math.PI*2);
            mapCtx.fill();
        }
        
        function animate() {
            requestAnimationFrame(animate);
            update();
            renderer.render(scene, camera);
        }
        
        init();
        animate();
    </script>
</body>
</html>
